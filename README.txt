Niniejszy program stanowi rozwiązanie trzech zadań konkursowych. 
Program wykorzystuje dedykowany, sporządzony indywidualnie do każdego zadania, parser tekstu wejściowego (http request body). Nie użyto w żadnym miejscu obiektów Java (więcej niż singleton), gdyż są one zasobożerne. Dla każdego zadania wszystkie informacje o danym „osobniku” udało się zmieścić w dedykowanej zmiennej, poszczególnych jej bitach w zapisie dwójkowym. (Zazwyczaj fragmenty zmiennej podzielone są wielokrotnością dwójki dla łatwiejszego dzielenia przesuwaniem bitów.) Dzięki temu sortowanie przeprowadza się raz, na tablicy zmiennych prymitywnych (2 z 3 przypadków) mających minimalny rozmiar tak, aby zmieścić wszystkie kluczowe dane. Informacje te nie zawsze są w tych zmiennych zapisane bezpośrednio (np. ich różnice względem stałej, jeśli kryteria są przeciwne dla kilku rodzajów danych wejściowych). Program ze względu na konkursowy charakter zadania i priorytet prędkości w bardzo ograniczonym zakresie posiada mechanizmy bezpieczeństwa (komunikaty o błędzie, wykrywanie nieprawidłowych i niezgodnych ze specyfikacją danych). Podanie złych wartości może spowodować zawieszenie lub zwrot tekstu INVALID DATA (nie jako obiekt JSON). Użyłem jedynie składni JAVA, choć dałoby się przyspieszyć działanie wywołując skompilowane poprzednio pod daną platformę procedury. Kod w pełni wykosztuje zalety JAVA, głównie możliwość uruchomienia w dowolnym środowisku z działającym JVM. W związku z brakiem informacji w regulaminie konkursu, założono, że do dyspozycji jest jedynie jeden wątek. W przypadku wielowątkowości i użycia wielu rdzeni pomimo, że czas może być krótszy, zużycie prądu na zadanie zakładając efektywne obciążenie maszyn obliczeniowych innymi także zadaniami będzie większe. Nawet przy jednym rdzeniu w pewnych aranżacjach pamięci cache wielowątkowość może działać szybciej. W tekście są pokomentowane fragmenty kodu przyspieszające jego działanie w przypadku wielu rdzeni (np. linie 132-137; 356-361).
W regulaminie i treści zadań pojawiły się pewne nieścisłości, które zinterpretowano w następujący sposób:
1.	W zadaniu „onlinegame” w tekście zadania określono maksymalną liczbę punktów jako 100 000. W specyfikacji „onlinegame.json” jest 1 000 000. Program obsługuje wartości do miliona. 
2.	W zadaniu dotyczącym kolejności obsługi bankomatów nie podano maksymalnej ich liczby. Program działa dla wartości mniejszych niż 100 000. Ponadto założono, że wartości numeru ragionu i numeru bankomatu nie są większe od 10 000.
3.	W zadaniu „transactions” tekst oraz podane przykłady „example_requestX.json” sugerują, że numer konta składa się z 26 cyfr. W specyfikacji „transactions.json” jako przykład podana jest wartość „3.2309111922661937e+25”, co sugeruje zmienną typu double. Tego typu zmienna nie nadaje się do przechowywania numeru rachunku ze względu na ograniczoną dokładność (około 15 cyfr znaczących w zapisie dziesiętnym). Bazując na ogólnej wiedzy (IBAN), założono, że numer rachunku składa się z 26 cyfr zapisanych bezpośrednio (nie w notacji inżynierskiej z potęgą dziesiątki). Podanie innych danych (innych niż 26 cyfr w miejscu numerów kont) spowoduje zawieszenie się programu lub nieprawidłową pracę. 
4.	W zadaniu „transactions” kwota sumaryczna i przelewana dla dowolnej kolejności obliczeń symulowanych transakcji nie powinna przekroczyć (z góry i z dołu) wartości signed int32. Przy czym wartość tej zmiennej reprezentuje setne części waluty. Czyli bilans rachunku powinien zawierać się w zakresie od – -21474836,47 do + 21474836,47. 
5.	W zadaniu „transactions” kwota przelewu według specyfikacji w pliku „transactions.json”  jest zmienną typu float. Bazując na wiedzy ogólnej zmienna taka ze względu na ograniczoną i trudną do przewidzenia dokładność niezbyt nadaje się do przechowywania kwot w systemach wymagających dużego zaufania. (aczkolwiek wspomnianą w punkcie 4. Dokładność wynikająca z int32 może spokojnie obsłużyć. Ponadto podane przykłady wywołań „example_requestX.json”, jak również wiedza ogólna (większość walut jest podzielna do 1/100) sugerują, że forma zapisu z dwoma miejscami po przecinku jest właściwa. (W podanym przykładzie zapisano np. „200.90”, zamiast „200.9” (co w przypadku zmiennej float byłoby bardziej eleganckie, może też sugerować niepewność wyznaczania wielkości w podejściu inżynierskim), co jest sugestywne.) Program w bieżącej wersji obsługuje jedynie wielkości zapisane z „.” (kropką) na drugim miejscu od końca ciągu cyfr, z minimum jedną cyfrą przed. A więc poprawne są ciągi 0.01; 0.99; 1.00; 100.10; 44.00, niepoprawne są natomiast .01; .99; 1; 100.1; 44. Przygotowałem także kod obsługujący zmienne float (wszystkie wspomniane przykłady byłyby poprawne), jest on znacznie wolniejszy, aby go uruchomić należy zakomentować linijki 112-118 i odkomentować 120-125 w kodzie źródłowym (jest w nich odpowiednie oznaczenie komentarzem). Obliczenia i tak są prowadzone dla dokładności setnej części. 
6.	W związku z priorytetem szybkości parser tekstu (request body, w formacie json) sporządzony został specjalnie dla podanych zadań.  Przyjmuje on jedynie dane wejściowe podane w kolejności takiej jak w dostarczonych plikach (specyfikacja i przykłady). Tak jest szybciej, program mogę szybko przerobić na dowolną kolejność. Z tego samego powodu program nie spełnia w pełni specyfikacji openapi oraz json (RFC 8259, ECMA-404, itd.), ale nigdzie nie jest powiedziane, ze ma spełniać. Dla dowolnych danych zgodnych z podanymi ograniczeniami i kolejności danych jak w dostarczonych przykładach program działa poprawnie, zwracając json. Można parser jeszcze przyspieszyć znając strukturę znaków białych, obecnie jest niewrażliwy na nią. Rozwiązanie takie sugerują podane przykłady wywołań = w każym z nich kolejność parametrów jest taka sama i tożsama z kolejnością w pliku definicyjnym openapi dla danego przypadku. 
Przyjęte powyżej założenia wynikają z niedoprecyzowania regulaminu i zadań. Jeśli są błędne program mogę szybko poprawić dokonując jedynie kluczowych z punktu widzenia danego aspektu zmian. 
Szybkość nie zawsze jest monotonicznie zmienna wraz z prędkością działania (szczególnie w przypadku wielordzeniowości), dlatego program nie używa tej funkcjonalności (poza sortowaniem dużych tablic, domyślnie zakomentowane w kodzie, linie 132-137; 356-361), nie zostało to też doprecyzowane w regulaminie. 
Program przetestowałem za pomocą swagger editora i własnych narzędzi sporządzonych w VB.NET (Visual Studio Enterprise 2019) dla szerokich zakresów danych wejściowych, od minimalnych wartości zmiennych, po maksymalne, od jednego osobnika w wejściowym jsonie (jedna transakcja, jeden bankomat do serwisowania, jeden klan z gry wraz z liczbą osób w pojedynczym wejściu) po maksymalną ich liczbę. Maksymalny czas wykonywania zadania dla najgorszego zestawu danych wejściowych o maksymalnej długości nieznacznie przekracza jedną dziesiątą sekundy przy użyciu jednego rdzenia Xeon E5-2680 v2 i po „rozgrzaniu” JVM. Błędów nie znalazłem, zwrotny JSON ma poprawny interpretowalny format. Mój czas na zadanie konkursowe jest ograniczony, mogę opowiedzieć o pomysłach na dalszą poprawę szybkości działania. Niektóre z nich wymagają znajomości statystycznego rozkładu wielkości i poziomu skomplikowania danych wejściowych. 


